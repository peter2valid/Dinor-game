<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dino Runner</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü¶ñ</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background-color: #f7f7f7;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            aspect-ratio: 3/1;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #f7f7f7;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .score-display {
            position: absolute;
            top: 10px;
            font-size: 18px;
            font-weight: bold;
            color: #666;
        }
        
        /* Goal banner so audience knows their task */
        #goal-banner {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.06);
            color: #333;
            padding: 6px 10px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            white-space: nowrap;
        }
        
        #hi-score {
            left: 10px;
        }
        
        #current-score {
            right: 10px;
        }
        
        .controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        
        .btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 18px;
            color: #333;
            border: none;
        }
        
        .btn:focus {
            outline: 2px solid rgba(0, 0, 0, 0.5);
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(247, 247, 247, 0.8);
            pointer-events: auto;
        }
        
        .overlay h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #333;
        }
        
        .overlay p {
            font-size: 18px;
            margin-bottom: 30px;
            color: #666;
            text-align: center;
            max-width: 80%;
        }
        
        .btn-large {
            padding: 12px 24px;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 18px;
            cursor: pointer;
            font-family: inherit;
        }
        
        .btn-large:focus {
            outline: 2px solid rgba(0, 0, 0, 0.5);
        }
        
        .touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            pointer-events: auto;
        }
        
        .touch-jump {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
        }
        
        .touch-duck {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 100%;
        }
        
        .hidden {
            display: none;
        }
        
        .debug-panel {
            position: absolute;
            top: 40px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px;
            font-size: 12px;
            border-radius: 4px;
            pointer-events: none;
        }
        
        @media (max-width: 600px) {
            .score-display {
                font-size: 16px;
            }
            
            .overlay h1 {
                font-size: 28px;
            }
            
            .overlay p {
                font-size: 16px;
            }
        }

        /* Audience-visible gift instructions under the game */
        #audience-instructions {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 16px;
            background: rgba(0, 0, 0, 0.05);
            padding: 8px 12px;
            border-radius: 10px;
            pointer-events: none;
        }
        #audience-instructions img {
            width: 40px;
            height: 40px;
            object-fit: contain;
            border-radius: 6px;
            pointer-events: none;
            background: #fff;
        }
        #audience-instructions .text {
            font-size: 16px;
            color: #333;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="900" height="300" aria-label="Dino Runner Game"></canvas>
        
        <div class="ui-layer">
            <div class="score-display" id="hi-score">HI 00000</div>
            <div class="score-display" id="current-score">00000</div>
            <div id="goal-banner" aria-live="polite" title="Send gifts to trigger effects">Send üåπ to restart ‚Ä¢ Send üç¶ for ice-cream mode</div>
            
            <div class="controls">
                <button class="btn" id="mute-btn" tabindex="1">üîä</button>
                <button class="btn" id="pause-btn" tabindex="2">‚è∏Ô∏è</button>
                <button class="btn" id="help-btn" tabindex="3">‚ùì</button>
                <button class="btn" id="easy-btn" tabindex="4" title="Toggle Easy Mode">EZ</button>
            </div>
            
            <div id="touch-controls" class="touch-controls hidden">
                <div class="touch-duck" id="touch-duck"></div>
                <div class="touch-jump" id="touch-jump"></div>
            </div>
        </div>
        
        <div id="title-screen" class="overlay">
            <h1>DINO RUNNER</h1>
            <p>Press SPACE or tap to start<br>Send üåπ to restart ‚Ä¢ Send üç¶ for ice-cream mode</p>
            <button class="btn-large" id="start-btn">START</button>
        </div>
        
        <div id="game-over" class="overlay hidden">
            <h1>GAME OVER</h1>
            <p>Score: <span id="final-score">00000</span> | HI: <span id="final-hi">00000</span></p>
            <button class="btn-large" id="restart-btn">PLAY AGAIN</button>
        </div>
        
        <div id="help-modal" class="overlay hidden">
            <h1>CONTROLS</h1>
            <p>SPACE/UP ARROW: Jump<br>DOWN ARROW: Duck<br>P: Pause/Resume</p>
            <p>On mobile: Tap right side to jump, left side to duck</p>
            <button class="btn-large" id="close-help-btn">CLOSE</button>
        </div>
        
        <div id="debug-panel" class="debug-panel hidden"></div>
    </div>

    <!-- Audience-facing images and instructions (always visible under game) -->
    <div id="audience-instructions" aria-hidden="false">
        <img src="public/tiktok rose.webp" alt="Rose gift icon" />
        <span class="text">Send a ROSE to restart</span>
        <img src="public/tiktok icecream.jpeg" alt="Ice cream gift icon" />
        <span class="text">Send ICE CREAM for ice-cream mode</span>
    </div>

    <script>
        // Game Constants and Configuration
        const CONFIG = {
            GRAVITY: 0.6,
            JUMP_FORCE: -12,
            GROUND_HEIGHT: 50,
            INITIAL_SPEED: 6,
            MAX_SPEED: 15,
            ACCELERATION: 0.001,
            COYOTE_TIME: 100,
            INVULNERABILITY_TIME: 1500,
            NIGHT_CYCLE_DURATION: 60000,
            STAR_COUNT: 30,
            CACTUS_SPAWN_RATE: 0.02,
            PTERODACTYL_SPAWN_RATE: 0.008,
            PTERODACTYL_MIN_SCORE: 100,
            POWERUP_SPAWN_RATE: 0.002,
            POWERUP_DURATION: 8000,
            SLOWMO_FACTOR: 0.5,
            COLLISION_BOX_PADDING: 5,
            EVENT_DURATION_MS: 8000
        };

        // Game State
        const GameState = {
            TITLE: 'title',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameOver'
        };

        // PowerUp Types
        const PowerUpType = {
            SHIELD: 'shield',
            SLOWMO: 'slowmo',
            MAGNET: 'magnet'
        };

        // Main Game Class
        class DinoGame {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // Scale for HiDPI screens
                this.scaleCanvas();
                window.addEventListener('resize', () => this.scaleCanvas());
                
                this.state = GameState.TITLE;
                this.score = 0;
                this.hiScore = this.loadHiScore();
                this.speed = CONFIG.INITIAL_SPEED;
                this.distance = 0;
                this.gameTime = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                
                this.isMuted = this.loadMuteSetting();
                this.isColorBlindMode = false;
                this.isReducedMotion = false;
                this.debugMode = false;
                this.isEasyMode = false; // keep difficulty normal
                this.autoPlay = true; // enable perfect autoplay
                this.autoRestartOnHit = false;
                this.scoreMultiplier = 1;
                this.autoJumpUntil = 0;
                this.totalLikes = 0;
                this.ghostModeUntil = 0;
                this.turboUntil = 0;
                this.flipUntil = 0;
                this.musicWarpUntil = 0;
                this.isIceCreamUntil = 0;
                
                // Obstacle spacing control
                this.nextSpawnTime = 0;
                this.minGap = 240; // pixels
                this.maxGap = 380; // pixels
                
                this.initializeElements();
                this.initializeAudio();
                this.initializeGameObjects();
                this.setupEventListeners();
                this.setupLiveEvents();
                
                this.updateHiScoreDisplay();
                this.updateMuteButton();
                this.updateEasyButton && this.updateEasyButton();
                
                this.animationId = null;
                this.lastFrameTime = performance.now();
                this.animate();
            }

            // --- Autoplay helpers ---
            getNearestObstacle() {
                let nearest = null;
                let nearestDist = Infinity;
                const playerFront = this.player.x + this.player.width;
                for (const o of this.obstacles) {
                    const d = o.x - playerFront;
                    if (d >= -10 && d < nearestDist) { // ahead or just overlapping
                        nearest = o;
                        nearestDist = d;
                    }
                }
                return nearest ? { obstacle: nearest, distance: nearestDist } : null;
            }

            // Predict if collision occurs within given frames without any action
            predictCollision(framesLookahead = 120) {
                let y = this.player.y;
                let height = this.player.height;
                let vy = this.player.velocityY;
                let isOnGround = this.player.isOnGround;
                const speedPerFrame = this.speed; // because we subtract speed * dt/16 elsewhere; dt ‚âà 16
                // clone minimal obstacle state
                const obs = this.obstacles.map(o => ({...o}));
                for (let f = 0; f < framesLookahead; f++) {
                    // advance player vertical
                    vy += CONFIG.GRAVITY;
                    y += vy;
                    const groundLevel = this.height - CONFIG.GROUND_HEIGHT - height;
                    if (y >= groundLevel) { y = groundLevel; vy = 0; isOnGround = true; } else { isOnGround = false; }
                    // advance obstacles
                    for (const o of obs) { o.x -= speedPerFrame; }
                    // check collisions
                    const box = { x: this.player.x, y, width: this.player.width, height };
                    for (const o of obs) {
                        if (!o.ghost && box.x < o.x + o.width && box.x + box.width > o.x && box.y < o.y + o.height && box.y + box.height > o.y) {
                            return { willCollide: true, frames: f + 1 };
                        }
                    }
                }
                return { willCollide: false, frames: framesLookahead };
            }

            // Try an action (jump now or duck for a window) and see if it avoids collisions
            actionAvoidsCollision(action, framesLookahead = 120) {
                let y = this.player.y;
                let height = this.player.height;
                let vy = this.player.velocityY;
                let isOnGround = this.player.isOnGround;
                let duckTimer = 0;
                const speedPerFrame = this.speed;
                const obs = this.obstacles.map(o => ({...o}));
                for (let f = 0; f < framesLookahead; f++) {
                    if (f === 0 && action === 'jump' && isOnGround) {
                        vy = CONFIG.JUMP_FORCE;
                        isOnGround = false;
                    }
                    if (action === 'duck') {
                        duckTimer = Math.max(duckTimer, 12); // hold duck ~200ms
                    }
                    if (duckTimer > 0) {
                        height = 30;
                        duckTimer--;
                    } else {
                        height = 47;
                    }
                    vy += CONFIG.GRAVITY;
                    y += vy;
                    const groundLevel = this.height - CONFIG.GROUND_HEIGHT - height;
                    if (y >= groundLevel) { y = groundLevel; vy = 0; isOnGround = true; } else { isOnGround = false; }
                    for (const o of obs) { o.x -= speedPerFrame; }
                    const box = { x: this.player.x, y, width: this.player.width, height };
                    for (const o of obs) {
                        if (!o.ghost && box.x < o.x + o.width && box.x + box.width > o.x && box.y < o.y + o.height && box.y + box.height > o.y) {
                            return false;
                        }
                    }
                }
                return true;
            }

            controlAutoPlay() {
                if (!this.autoPlay || this.state !== GameState.PLAYING) return;
                const info = this.getNearestObstacle();
                if (!info) {
                    // release duck if no threat
                    this.player.isDucking = false;
                    return;
                }
                const { obstacle, distance } = info;
                const lookahead = 300;
                if (distance > lookahead) return;

                // Estimated frames until contact (we advance obstacles by speed per frame in prediction)
                const framesToContact = Math.max(1, Math.floor(distance / Math.max(1, this.speed)));

                if (obstacle.type === 'pterodactyl') {
                    // If wings sweep near body height, duck; otherwise, ignore
                    const playerTop = this.player.y;
                    const playerBottom = this.player.y + this.player.height;
                    const overlapSoon = !(playerBottom < obstacle.y || playerTop > obstacle.y + obstacle.height) || framesToContact < 12;
                    if (overlapSoon) {
                        // If high pterodactyl, jump; if mid/low, duck
                        const isHigh = obstacle.y + obstacle.height < this.player.y + 20;
                        if (isHigh && this.player.isOnGround && framesToContact < 18) {
                            if (this.actionAvoidsCollision('jump', 90)) {
                                this.jump();
                                this.player.isDucking = false;
                            }
                        } else {
                            if (this.actionAvoidsCollision('duck', 90)) {
                                this.player.isDucking = true;
                                setTimeout(() => this.player.isDucking = false, 250);
                            }
                        }
                    }
                    return;
                }

                // Ground obstacles (cacti variants)
                const variant = obstacle.variant ?? 2;
                const triggerFramesByVariant = [16, 18, 20];
                const baseTrigger = triggerFramesByVariant[Math.max(0, Math.min(2, variant))];
                const dynamicTrigger = baseTrigger + (this.speed < 8 ? 6 : this.speed < 12 ? 3 : 0);
                if (this.player.isOnGround && framesToContact <= dynamicTrigger) {
                    // Search small window for best jump frame
                    for (let delay = 0; delay <= 8; delay++) {
                        if (this.actionAvoidsCollision('jump', 110)) {
                            this.jump();
                            break;
                        }
                    }
                }
            }
            
            scaleCanvas() {
                const container = this.canvas.parentElement;
                const scale = Math.min(container.clientWidth / this.width, container.clientHeight / this.height);
                
                this.canvas.style.width = `${this.width * scale}px`;
                this.canvas.style.height = `${this.height * scale}px`;
            }
            
            initializeElements() {
                this.titleScreen = document.getElementById('title-screen');
                this.gameOverScreen = document.getElementById('game-over');
                this.helpModal = document.getElementById('help-modal');
                this.debugPanel = document.getElementById('debug-panel');
                this.touchControls = document.getElementById('touch-controls');
                this.currentScoreDisplay = document.getElementById('current-score');
                this.hiScoreDisplay = document.getElementById('hi-score');
                this.finalScoreDisplay = document.getElementById('final-score');
                this.finalHiScoreDisplay = document.getElementById('final-hi');
                this.muteBtn = document.getElementById('mute-btn');
                this.pauseBtn = document.getElementById('pause-btn');
                this.easyBtn = document.getElementById('easy-btn');
                
                // Show touch controls on mobile
                if ('ontouchstart' in window) {
                    this.touchControls.classList.remove('hidden');
                }
            }
            
            initializeAudio() {
                this.audioContext = null;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API is not supported in this browser');
                }
            }

            setupLiveEvents() {
                try {
                    const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
                    const ws = new WebSocket(`${protocol}://${location.host}`);
                    ws.onmessage = (ev) => {
                        const msg = JSON.parse(ev.data || '{}');
                        this.handleLiveEvent(msg);
                    };
                } catch (e) {
                    console.warn('Live events unavailable:', e);
                }
            }

            handleLiveEvent(msg) {
                const now = Date.now();
                if (!msg || !msg.type) return;
                switch (msg.type) {
                    case 'like': {
                        const inc = msg.payload && msg.payload.likeCount ? msg.payload.likeCount : 1;
                        this.totalLikes += inc;
                        if (this.totalLikes % 50 === 0) this.spawnCactus(Math.floor(Math.random() * 3));
                        if (this.totalLikes % 500 === 0) this.autoJumpUntil = now + 10000;
                        break;
                    }
                    case 'comment': {
                        const text = (msg.payload && msg.payload.comment ? msg.payload.comment : '').toLowerCase();
                        if (text.includes('jump')) this.jump();
                        if (text.includes('duck')) { this.player.isDucking = true; setTimeout(()=> this.player.isDucking = false, 800); }
                        break;
                    }
                    case 'follow': {
                        this.player.activePowerUps.set(PowerUpType.SHIELD, { type: PowerUpType.SHIELD, duration: CONFIG.POWERUP_DURATION });
                        break;
                    }
                    case 'share': {
                        this.spawnPowerUp();
                        break;
                    }
                    case 'gift': {
                        const name = (msg.payload && msg.payload.giftName ? msg.payload.giftName : '').toLowerCase();
                        if (name.includes('rose')) {
                            this.restartGame();
                        } else if (name.includes('perfume') || name.includes('tiktok')) {
                            this.flipUntil = now + 5000;
                        } else if (name.includes('ice') || name.includes('cream')) {
                            this.isIceCreamUntil = now + 8000;
                        } else if (name.includes('lion')) {
                            this.spawnLionBoss(now + 10000);
                        } else if (name.includes('castle')) {
                            this.player.activePowerUps.set(PowerUpType.SHIELD, { type: PowerUpType.SHIELD, duration: CONFIG.EVENT_DURATION_MS });
                            this.player.activePowerUps.set(PowerUpType.SLOWMO, { type: PowerUpType.SLOWMO, duration: CONFIG.EVENT_DURATION_MS });
                            this.player.activePowerUps.set(PowerUpType.MAGNET, { type: PowerUpType.MAGNET, duration: CONFIG.EVENT_DURATION_MS });
                        } else if (name.includes('gg') || name.includes('wave')) {
                            this.ghostModeUntil = now + CONFIG.EVENT_DURATION_MS;
                            this.spawnGhostObstacles();
                        } else if (name.includes('fire')) {
                            this.turboUntil = now + 5000;
                            this.scoreMultiplier = 2;
                        } else if (name.includes('music')) {
                            this.musicWarpUntil = now + CONFIG.EVENT_DURATION_MS;
                        } else if (name.includes('diamond')) {
                            this.spawnGemShower();
                        }
                        break;
                    }
                }
            }
            
            initializeGameObjects() {
                // Player
                this.player = {
                    x: 80,
                    y: this.height - CONFIG.GROUND_HEIGHT,
                    width: 44,
                    height: 47,
                    velocityY: 0,
                    isJumping: false,
                    isDucking: false,
                    isOnGround: true,
                    lastGroundTime: 0,
                    jumpBuffer: false,
                    frame: 0,
                    frameTime: 0,
                    isInvulnerable: false,
                    invulnerabilityTime: 0,
                    activePowerUps: new Map()
                };
                
                // Game objects
                this.ground = {
                    x: 0,
                    tiles: []
                };
                
                this.obstacles = [];
                this.powerUps = [];
                this.particles = [];
                this.gems = [];
                this.clouds = [];
                this.stars = [];
                this.hills = [];
                
                this.initializeEnvironment();
            }
            
            initializeEnvironment() {
                // Initialize ground tiles
                for (let i = 0; i < Math.ceil(this.width / 30) + 1; i++) {
                    this.ground.tiles.push(i * 30);
                }
                
                // Initialize clouds
                for (let i = 0; i < 5; i++) {
                    this.clouds.push({
                        x: Math.random() * this.width,
                        y: Math.random() * 70 + 30,
                        width: Math.random() * 40 + 60,
                        speed: Math.random() * 0.5 + 0.2
                    });
                }
                
                // Initialize hills
                for (let i = 0; i < 3; i++) {
                    this.hills.push({
                        x: Math.random() * this.width,
                        y: this.height - CONFIG.GROUND_HEIGHT,
                        width: Math.random() * 100 + 100,
                        height: Math.random() * 30 + 20,
                        speed: Math.random() * 0.3 + 0.1
                    });
                }
                
                // Initialize stars
                for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
                    this.stars.push({
                        x: Math.random() * this.width,
                        y: Math.random() * (this.height - CONFIG.GROUND_HEIGHT - 50) + 20,
                        size: Math.random() * 2 + 1,
                        brightness: Math.random() * 0.5 + 0.5
                    });
                }
            }
            
            setupEventListeners() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (this.state === GameState.TITLE && (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowUp')) {
                        this.startGame();
                    } else if (this.state === GameState.GAME_OVER && (e.code === 'Space' || e.code === 'Enter')) {
                        this.restartGame();
                    } else if (e.code === 'KeyP') {
                        this.togglePause();
                    } else if (this.state === GameState.PLAYING) {
                        if ((e.code === 'Space' || e.code === 'ArrowUp') && !this.player.isJumping) {
                            this.jump();
                        } else if (e.code === 'ArrowDown') {
                            this.player.isDucking = true;
                        } else if (e.code === 'KeyD') {
                            this.debugMode = !this.debugMode;
                            this.debugPanel.classList.toggle('hidden', !this.debugMode);
                        } else if (e.code === 'KeyR') {
                            // Reseed RNG for testing
                            Math.seed = Date.now();
                        } else if (e.code === 'KeyS') {
                            // Toggle slowmo for testing
                            this.toggleSlowMo();
                        } else if (e.code === 'KeyH') {
                            // Add 100 score for testing
                            this.addScore(100);
                        } else if (e.code === 'Digit1') {
                            this.spawnCactus(0);
                        } else if (e.code === 'Digit2') {
                            this.spawnCactus(1);
                        } else if (e.code === 'Digit3') {
                            this.spawnPterodactyl();
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'ArrowDown') {
                        this.player.isDucking = false;
                    }
                });
                
                // Touch controls
                document.getElementById('touch-jump').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.state === GameState.TITLE) {
                        this.startGame();
                    } else if (this.state === GameState.GAME_OVER) {
                        this.restartGame();
                    } else if (this.state === GameState.PLAYING && !this.player.isJumping) {
                        this.jump();
                    }
                });
                
                document.getElementById('touch-duck').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.state === GameState.PLAYING) {
                        this.player.isDucking = true;
                    }
                });
                
                document.getElementById('touch-duck').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.player.isDucking = false;
                });
                
                // Double tap to pause
                let lastTap = 0;
                this.canvas.addEventListener('touchstart', (e) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    
                    if (tapLength < 300 && tapLength > 0) {
                        this.togglePause();
                    }
                    
                    lastTap = currentTime;
                });
                
                // Button events
                document.getElementById('start-btn').addEventListener('click', () => this.startGame());
                document.getElementById('restart-btn').addEventListener('click', () => this.restartGame());
                document.getElementById('help-btn').addEventListener('click', () => this.showHelp());
                document.getElementById('close-help-btn').addEventListener('click', () => this.hideHelp());
                this.muteBtn.addEventListener('click', () => this.toggleMute());
                this.pauseBtn.addEventListener('click', () => this.togglePause());
                this.easyBtn.addEventListener('click', () => this.toggleEasyMode());
            }
            
            startGame() {
                this.state = GameState.PLAYING;
                this.titleScreen.classList.add('hidden');
                this.gameOverScreen.classList.add('hidden');
                this.helpModal.classList.add('hidden');
                
                this.score = 0;
                this.speed = CONFIG.INITIAL_SPEED;
                this.distance = 0;
                this.gameTime = 0;
                
                this.player.y = this.height - CONFIG.GROUND_HEIGHT;
                this.player.velocityY = 0;
                this.player.isJumping = false;
                this.player.isDucking = false;
                this.player.isOnGround = true;
                this.player.isInvulnerable = true;
                this.player.invulnerabilityTime = this.autoPlay ? 0 : CONFIG.INVULNERABILITY_TIME;
                this.player.activePowerUps.clear();
                // no permanent invulnerability: we want challenge with auto-play
                
                this.obstacles = [];
                this.powerUps = [];
                this.particles = [];
                
                this.updateScoreDisplay();
            }
            
            restartGame() {
                this.startGame();
            }
            
            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    this.pauseBtn.textContent = '‚ñ∂Ô∏è';
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    this.pauseBtn.textContent = '‚è∏Ô∏è';
                }
            }
            
            showHelp() {
                this.helpModal.classList.remove('hidden');
            }
            
            hideHelp() {
                this.helpModal.classList.add('hidden');
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                this.updateMuteButton();
                this.saveMuteSetting();
            }
            
            toggleEasyMode() {
                this.isEasyMode = !this.isEasyMode;
                this.updateEasyButton();
            }
            
            updateMuteButton() {
                this.muteBtn.textContent = this.isMuted ? 'üîá' : 'üîä';
            }
            
            updateEasyButton() {
                if (!this.easyBtn) return;
                this.easyBtn.textContent = this.isEasyMode ? 'EZ' : 'HD';
                this.easyBtn.title = this.isEasyMode ? 'Easy Mode: ON' : 'Easy Mode: OFF';
            }
            
            gameOver() {
                if (this.autoRestartOnHit) {
                    this.restartGame();
                    return;
                }
                this.state = GameState.GAME_OVER;
                if (this.score > this.hiScore) {
                    this.hiScore = this.score;
                    this.saveHiScore();
                }
                this.finalScoreDisplay.textContent = this.score.toString().padStart(5, '0');
                this.finalHiScoreDisplay.textContent = this.hiScore.toString().padStart(5, '0');
                this.gameOverScreen.classList.remove('hidden');
                this.playSound('thud');
            }
            
            jump() {
                if (this.player.isOnGround || (performance.now() - this.player.lastGroundTime < CONFIG.COYOTE_TIME)) {
                    this.player.velocityY = CONFIG.JUMP_FORCE;
                    this.player.isJumping = true;
                    this.player.isOnGround = false;
                    this.playSound('jump');
                    return true;
                } else if (this.player.jumpBuffer) {
                    // Already buffered a jump
                    return false;
                }
                
                // Buffer the jump input
                this.player.jumpBuffer = true;
                setTimeout(() => {
                    this.player.jumpBuffer = false;
                }, 200);
                
                return false;
            }
            
            addScore(points) {
                this.score += points;
                
                // Check for milestone
                if (this.score % 100 === 0) {
                    this.playSound('ding');
                    
                    // Flash score display
                    this.currentScoreDisplay.style.color = '#ff9900';
                    setTimeout(() => {
                        this.currentScoreDisplay.style.color = '#666';
                    }, 300);
                }
                
                this.updateScoreDisplay();
            }
            
            updateScoreDisplay() {
                this.currentScoreDisplay.textContent = this.score.toString().padStart(5, '0');
            }
            
            updateHiScoreDisplay() {
                this.hiScoreDisplay.textContent = `HI ${this.hiScore.toString().padStart(5, '0')}`;
            }
            
            loadHiScore() {
                try {
                    return parseInt(localStorage.getItem('dino_hi') || '0');
                } catch (e) {
                    return 0;
                }
            }
            
            saveHiScore() {
                try {
                    localStorage.setItem('dino_hi', this.hiScore.toString());
                    this.updateHiScoreDisplay();
                } catch (e) {
                    // Ignore localStorage errors
                }
            }
            
            loadMuteSetting() {
                try {
                    return localStorage.getItem('dino_mute') === 'true';
                } catch (e) {
                    return false;
                }
            }
            
            saveMuteSetting() {
                try {
                    localStorage.setItem('dino_mute', this.isMuted.toString());
                } catch (e) {
                    // Ignore localStorage errors
                }
            }
            
            playSound(type) {
                if (this.isMuted || !this.audioContext) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    switch (type) {
                        case 'jump':
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(523.25, this.audioContext.currentTime); // C5
                            oscillator.frequency.exponentialRampToValueAtTime(261.63, this.audioContext.currentTime + 0.2); // C4
                            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                            break;
                            
                        case 'ding':
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(1046.5, this.audioContext.currentTime); // C6
                            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                            break;
                            
                        case 'thud':
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(110, this.audioContext.currentTime); // A2
                            oscillator.frequency.exponentialRampToValueAtTime(55, this.audioContext.currentTime + 0.3); // A1
                            gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                            break;
                            
                        case 'powerup':
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(523.25, this.audioContext.currentTime); // C5
                            oscillator.frequency.exponentialRampToValueAtTime(1046.5, this.audioContext.currentTime + 0.1); // C6
                            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                            break;
                    }
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                } catch (e) {
                    console.warn('Audio error:', e);
                }
            }
            
            toggleSlowMo() {
                if (this.player.activePowerUps.has(PowerUpType.SLOWMO)) {
                    this.player.activePowerUps.delete(PowerUpType.SLOWMO);
                } else {
                    this.player.activePowerUps.set(PowerUpType.SLOWMO, {
                        type: PowerUpType.SLOWMO,
                        duration: CONFIG.POWERUP_DURATION
                    });
                }
            }
            
            spawnCactus(type) {
                const width = type === 0 ? 20 : 40;
                const height = type === 0 ? 40 : type === 1 ? 30 : 50;
                
                this.obstacles.push({
                    type: 'cactus',
                    x: this.width,
                    y: this.height - CONFIG.GROUND_HEIGHT - height,
                    width: width,
                    height: height,
                    variant: type
                });
            }
            
            spawnPterodactyl() {
                const altitudes = [this.height - CONFIG.GROUND_HEIGHT - 60, this.height - CONFIG.GROUND_HEIGHT - 90, this.height - CONFIG.GROUND_HEIGHT - 120];
                const altitude = altitudes[Math.floor(Math.random() * altitudes.length)];
                
                this.obstacles.push({
                    type: 'pterodactyl',
                    x: this.width,
                    y: altitude,
                    width: 46,
                    height: 20,
                    frame: 0,
                    frameTime: 0
                });
            }
            
            spawnPowerUp() {
                const types = [PowerUpType.SHIELD, PowerUpType.SLOWMO, PowerUpType.MAGNET];
                const type = types[Math.floor(Math.random() * types.length)];
                
                this.powerUps.push({
                    type: type,
                    x: this.width,
                    y: this.height - CONFIG.GROUND_HEIGHT - 40,
                    width: 30,
                    height: 30
                });
            }
            
            spawnDustParticles(x, y, count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        size: Math.random() * 5 + 2,
                        speedX: Math.random() * 3 - 1.5,
                        speedY: Math.random() * -2 - 1,
                        life: 30
                    });
                }
            }
            
            checkCollision(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
            
            update(deltaTime) {
                if (this.state !== GameState.PLAYING) return;
                
                this.gameTime += deltaTime;
                this.distance += this.speed * deltaTime / 16;
                
                const now = performance.now();
                if (this.turboUntil && now > this.turboUntil) { this.turboUntil = 0; this.scoreMultiplier = 1; }
                if (this.ghostModeUntil && now > this.ghostModeUntil) this.ghostModeUntil = 0;
                if (this.flipUntil && now > this.flipUntil) this.flipUntil = 0;
                if (this.musicWarpUntil && now > this.musicWarpUntil) this.musicWarpUntil = 0;
                if (this.isIceCreamUntil && now > this.isIceCreamUntil) this.isIceCreamUntil = 0;
                
                // Update score based on distance
                if (this.distance >= 10) {
                    this.addScore(1);
                    this.distance = 0;
                }
                
                // Gradually increase speed
                let baseSpeed = Math.min(CONFIG.MAX_SPEED, CONFIG.INITIAL_SPEED + this.score * CONFIG.ACCELERATION);
                if (this.isEasyMode) baseSpeed *= 0.7;
                this.speed = this.turboUntil ? baseSpeed * 1.6 : baseSpeed;
                
                // Update player
                this.updatePlayer(deltaTime);
                
                // Update obstacles
                this.updateObstacles(deltaTime);
                
                // Update power-ups
                this.updatePowerUps(deltaTime);
                
                // Update particles
                this.updateParticles();
                this.updateGems();
                
                // Update environment
                this.updateEnvironment(deltaTime);
                
                // Spawn new obstacles
                this.spawnObstacles();
                
                // Spawn power-ups occasionally
                if (Math.random() < CONFIG.POWERUP_SPAWN_RATE * deltaTime / 16) {
                    this.spawnPowerUp();
                }
            }
            
            updatePlayer(deltaTime) {
                // Apply gravity
                this.player.velocityY += CONFIG.GRAVITY;
                this.player.y += this.player.velocityY;
                
                // Check ground collision
                const groundLevel = this.height - CONFIG.GROUND_HEIGHT - this.player.height;
                if (this.player.y >= groundLevel) {
                    this.player.y = groundLevel;
                    this.player.velocityY = 0;
                    
                    if (!this.player.isOnGround) {
                        this.player.isOnGround = true;
                        this.player.lastGroundTime = performance.now();
                        
                        // Spawn dust particles when landing
                        this.spawnDustParticles(this.player.x, this.player.y + this.player.height, 5);
                    }
                    
                    this.player.isJumping = false;
                    
                    // Process buffered jump
                    if (this.player.jumpBuffer) {
                        this.jump();
                        this.player.jumpBuffer = false;
                    }
                } else {
                    this.player.isOnGround = false;
                }
                
                // Handle ducking
                if (this.player.isDucking) {
                    this.player.height = 30;
                    this.player.y = this.height - CONFIG.GROUND_HEIGHT - this.player.height;
                } else {
                    this.player.height = 47;
                }
                
                // Perfect AutoPlay control loop
                if (this.autoPlay && this.state === GameState.PLAYING) {
                    this.controlAutoPlay();
                } else if ((this.autoJumpUntil > performance.now() || this.isEasyMode) && this.player.isOnGround) {
                    const threat = this.obstacles.find(o => o.x - (this.player.x + this.player.width) < 80 && o.x > this.player.x - 10 && o.y + o.height > this.player.y);
                    if (threat) this.jump();
                }
                
                // Update animation frame
                this.player.frameTime += deltaTime;
                if (this.player.frameTime > 100) {
                    this.player.frame = (this.player.frame + 1) % 2;
                    this.player.frameTime = 0;
                }
                
                // Update invulnerability
                if (this.player.isInvulnerable) {
                    this.player.invulnerabilityTime -= deltaTime;
                    if (this.player.invulnerabilityTime <= 0) {
                        this.player.isInvulnerable = false;
                    }
                }
                
                // Update active power-ups
                for (const [type, powerUp] of this.player.activePowerUps) {
                    powerUp.duration -= deltaTime;
                    if (powerUp.duration <= 0) {
                        this.player.activePowerUps.delete(type);
                    }
                }
            }
            
            updateObstacles(deltaTime) {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.x -= this.speed * deltaTime / 16;
                    
                    // Update pterodactyl animation
                    if (obstacle.type === 'pterodactyl') {
                        obstacle.frameTime += deltaTime;
                        if (obstacle.frameTime > 150) {
                            obstacle.frame = (obstacle.frame + 1) % 2;
                            obstacle.frameTime = 0;
                        }
                    }
                    
                    // Check collision
                    if (!obstacle.ghost && this.checkCollision(this.player, obstacle)) {
                        if (this.isEasyMode) {
                            // Ignore collisions in easy mode
                            this.obstacles.splice(i, 1);
                            continue;
                        }
                        if (this.player.activePowerUps.has(PowerUpType.SHIELD)) {
                            this.player.activePowerUps.delete(PowerUpType.SHIELD);
                            this.obstacles.splice(i, 1);
                            continue;
                        }
                        
                        if (!this.player.isInvulnerable) {
                            if (this.autoPlay) {
                                // In autoplay, ignore hits and continue; gently push player back to ground
                                this.player.isDucking = true;
                                setTimeout(() => this.player.isDucking = false, 200);
                                this.obstacles.splice(i, 1);
                                continue;
                            } else {
                                this.gameOver();
                                return;
                            }
                        }
                    }
                    
                    // Remove obstacles that are off-screen
                    if (obstacle.x + obstacle.width < 0) {
                        this.obstacles.splice(i, 1);
                    }
                }
            }
            
            updatePowerUps(deltaTime) {
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    powerUp.x -= this.speed * deltaTime / 16;
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, powerUp)) {
                        this.player.activePowerUps.set(powerUp.type, {
                            type: powerUp.type,
                            duration: CONFIG.POWERUP_DURATION
                        });
                        
                        this.powerUps.splice(i, 1);
                        this.playSound('powerup');
                        continue;
                    }
                    
                    // Remove power-ups that are off-screen
                    if (powerUp.x + powerUp.width < 0) {
                        this.powerUps.splice(i, 1);
                    }
                }
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            updateGems() {
                for (let i = this.gems.length - 1; i >= 0; i--) {
                    const g = this.gems[i];
                    g.x += g.vx;
                    g.y += g.vy;
                    g.vy += 0.15;
                    if (g.y > this.height - CONFIG.GROUND_HEIGHT - 8) { g.vy *= -0.5; g.y = this.height - CONFIG.GROUND_HEIGHT - 8; }
                    const box = { x: g.x, y: g.y, width: 8, height: 8 };
                    if (this.checkCollision(this.player, box)) {
                        this.addScore(10);
                        this.gems.splice(i, 1);
                        continue;
                    }
                    if (g.life-- <= 0) this.gems.splice(i, 1);
                }
            }
            
            updateEnvironment(deltaTime) {
                // Update ground
                for (let i = 0; i < this.ground.tiles.length; i++) {
                    this.ground.tiles[i] -= this.speed * deltaTime / 16;
                    
                    if (this.ground.tiles[i] + 30 < 0) {
                        this.ground.tiles[i] = this.width; 
                    }
                }
                
                // Update clouds
                for (let i = 0; i < this.clouds.length; i++) {
                    const cloud = this.clouds[i];
                    cloud.x -= cloud.speed * deltaTime / 16;
                    
                    if (cloud.x + cloud.width < 0) {
                        cloud.x = this.width;
                        cloud.y = Math.random() * 70 + 30;
                    }
                }
                
                // Update hills
                for (let i = 0; i < this.hills.length; i++) {
                    const hill = this.hills[i];
                    hill.x -= hill.speed * deltaTime / 16;
                    
                    if (hill.x + hill.width < 0) {
                        hill.x = this.width;
                    }
                }
            }
            
            spawnObstacles() {
                // Even spacing via scheduling
                if (this.gameTime < this.nextSpawnTime) return;
                
                // Avoid clustering when external spawns happen
                const edge = this.width - 20;
                for (const o of this.obstacles) {
                    if (o.x > edge) {
                        this.nextSpawnTime = this.gameTime + 250;
                        return;
                    }
                }
                
                const canSpawnPterodactyl = this.score >= CONFIG.PTERODACTYL_MIN_SCORE;
                const spawnFlying = canSpawnPterodactyl && Math.random() < 0.35;
                if (spawnFlying) {
                    this.spawnPterodactyl();
                } else {
                    const type = Math.floor(Math.random() * 3);
                    this.spawnCactus(type);
                }
                
                const gapPx = this.minGap + Math.random() * (this.maxGap - this.minGap);
                const framesNeeded = gapPx / Math.max(1, this.speed);
                this.nextSpawnTime = this.gameTime + framesNeeded * 16;
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Draw sky with day/night cycle
                this.drawSky();
                
                // Draw environment
                this.drawEnvironment();
                
                // Draw player
                this.drawPlayer();
                
                // Draw obstacles
                this.drawObstacles();
                
                // Draw power-ups
                this.drawPowerUps();
                
                // Draw particles
                this.drawParticles();
                // Draw gems
                this.drawGems();
                
                // Draw debug info
                if (this.debugMode) {
                    this.drawDebugInfo();
                }
            }
            
            drawSky() {
                // Calculate time of day (0 to 1, repeating)
                const timeOfDay = (this.gameTime % CONFIG.NIGHT_CYCLE_DURATION) / CONFIG.NIGHT_CYCLE_DURATION;
                
                // Interpolate between day and night colors
                let skyColor, groundColor;
                
                if (timeOfDay < 0.5) {
                    // Day to night transition
                    const t = timeOfDay * 2;
                    skyColor = this.interpolateColor('#f7f7f7', '#0c1445', t);
                    groundColor = this.interpolateColor('#f7f7f7', '#2c3e50', t);
                } else {
                    // Night to day transition
                    const t = (timeOfDay - 0.5) * 2;
                    skyColor = this.interpolateColor('#0c1445', '#f7f7f7', t);
                    groundColor = this.interpolateColor('#2c3e50', '#f7f7f7', t);
                }
                
                // Draw sky
                this.ctx.fillStyle = skyColor;
                this.ctx.fillRect(0, 0, this.width, this.height - CONFIG.GROUND_HEIGHT);
                
                // Draw stars at night
                if (timeOfDay > 0.25 && timeOfDay < 0.75) {
                    const starVisibility = Math.min(1, Math.abs(timeOfDay - 0.5) * 4);
                    
                    for (const star of this.stars) {
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * starVisibility})`;
                        this.ctx.fillRect(star.x, star.y, star.size, star.size);
                    }
                }
                
                // Draw ground
                this.ctx.fillStyle = groundColor;
                this.ctx.fillRect(0, this.height - CONFIG.GROUND_HEIGHT, this.width, CONFIG.GROUND_HEIGHT);
                
                // Draw ground lines
                this.ctx.fillStyle = timeOfDay < 0.5 ? '#666' : '#999';
                for (const tileX of this.ground.tiles) {
                    this.ctx.fillRect(tileX, this.height - CONFIG.GROUND_HEIGHT, 30, 2);
                }
            }
            
            interpolateColor(color1, color2, t) {
                // Parse hex colors
                const r1 = parseInt(color1.substring(1, 3), 16);
                const g1 = parseInt(color1.substring(3, 5), 16);
                const b1 = parseInt(color1.substring(5, 7), 16);
                
                const r2 = parseInt(color2.substring(1, 3), 16);
                const g2 = parseInt(color2.substring(3, 5), 16);
                const b2 = parseInt(color2.substring(5, 7), 16);
                
                // Interpolate
                const r = Math.round(r1 + (r2 - r1) * t);
                const g = Math.round(g1 + (g2 - g1) * t);
                const b = Math.round(b1 + (b2 - b1) * t);
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            
            drawEnvironment() {
                // Draw hills
                this.ctx.fillStyle = this.isColorBlindMode ? '#555' : '#ddd';
                for (const hill of this.hills) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(hill.x, hill.y);
                    this.ctx.lineTo(hill.x + hill.width, hill.y);
                    this.ctx.lineTo(hill.x + hill.width, hill.y - hill.height);
                    this.ctx.lineTo(hill.x, hill.y - hill.height);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
                
                // Draw clouds
                this.ctx.fillStyle = this.isColorBlindMode ? '#777' : '#eee';
                for (const cloud of this.clouds) {
                    this.ctx.beginPath();
                    this.ctx.ellipse(cloud.x + cloud.width * 0.3, cloud.y, cloud.width * 0.3, cloud.width * 0.2, 0, 0, Math.PI * 2);
                    this.ctx.ellipse(cloud.x + cloud.width * 0.7, cloud.y, cloud.width * 0.3, cloud.width * 0.2, 0, 0, Math.PI * 2);
                    this.ctx.ellipse(cloud.x + cloud.width * 0.5, cloud.y - cloud.width * 0.1, cloud.width * 0.4, cloud.width * 0.2, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            drawPlayer() {
                // Draw player with invulnerability flash
                if (this.player.isInvulnerable && Math.floor(this.player.invulnerabilityTime / 100) % 2 === 0) {
                    return; // Skip drawing every other frame for flash effect
                }
                
                this.ctx.fillStyle = this.isIceCreamUntil ? '#f39' : (this.isColorBlindMode ? '#000' : '#333');
                
                if (this.isIceCreamUntil) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.player.x + this.player.width / 2, this.player.y);
                    this.ctx.lineTo(this.player.x, this.player.y + this.player.height);
                    this.ctx.lineTo(this.player.x + this.player.width, this.player.y + this.player.height);
                    this.ctx.closePath();
                    this.ctx.fill();
                } else if (this.player.isDucking) {
                    // Draw ducking dino
                    this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                    
                    // Draw legs
                    this.ctx.fillRect(this.player.x + 10, this.player.y + this.player.height - 5, 8, 5);
                    this.ctx.fillRect(this.player.x + 26, this.player.y + this.player.height - 5, 8, 5);
                } else if (this.player.isJumping) {
                    // Draw jumping dino
                    this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                    
                    // Draw legs tucked
                    this.ctx.fillRect(this.player.x + 10, this.player.y + this.player.height - 15, 8, 15);
                    this.ctx.fillRect(this.player.x + 26, this.player.y + this.player.height - 15, 8, 15);
                } else {
                    // Draw running dino with animation
                    this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                    
                    // Draw legs based on animation frame
                    if (this.player.frame === 0) {
                        this.ctx.fillRect(this.player.x + 10, this.player.y + this.player.height - 15, 8, 15);
                        this.ctx.fillRect(this.player.x + 26, this.player.y + this.player.height - 5, 8, 5);
                    } else {
                        this.ctx.fillRect(this.player.x + 10, this.player.y + this.player.height - 5, 8, 5);
                        this.ctx.fillRect(this.player.x + 26, this.player.y + this.player.height - 15, 8, 15);
                    }
                }
                
                // Draw active power-up icons
                let iconY = this.player.y - 30;
                for (const [type] of this.player.activePowerUps) {
                    this.ctx.fillStyle = this.getPowerUpColor(type);
                    this.ctx.beginPath();
                    
                    switch (type) {
                        case PowerUpType.SHIELD:
                            this.ctx.arc(this.player.x + this.player.width / 2, iconY, 10, 0, Math.PI * 2);
                            break;
                            
                        case PowerUpType.SLOWMO:
                            this.ctx.moveTo(this.player.x + this.player.width / 2 - 8, iconY - 8);
                            this.ctx.lineTo(this.player.x + this.player.width / 2 + 8, iconY);
                            this.ctx.lineTo(this.player.x + this.player.width / 2 - 8, iconY + 8);
                            this.ctx.closePath();
                            break;
                            
                        case PowerUpType.MAGNET:
                            this.ctx.moveTo(this.player.x + this.player.width / 2, iconY - 10);
                            this.ctx.lineTo(this.player.x + this.player.width / 2 - 8, iconY);
                            this.ctx.lineTo(this.player.x + this.player.width / 2, iconY + 10);
                            this.ctx.lineTo(this.player.x + this.player.width / 2 + 8, iconY);
                            this.ctx.closePath();
                            break;
                    }
                    
                    this.ctx.fill();
                    iconY -= 25;
                }
                
                // Draw collision box in debug mode
                if (this.debugMode) {
                    this.ctx.strokeStyle = 'red';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(this.player.x, this.player.y, this.player.width, this.player.height);
                }
            }
            
            drawObstacles() {
                this.ctx.fillStyle = this.isColorBlindMode ? '#900' : '#333';
                
                for (const obstacle of this.obstacles) {
                    if (obstacle.type === 'lion') {
                        this.ctx.fillStyle = '#c93';
                        this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        this.ctx.fillStyle = this.isColorBlindMode ? '#900' : '#333';
                        
                        if (this.debugMode) {
                            this.ctx.strokeStyle = 'blue';
                            this.ctx.lineWidth = 1;
                            this.ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        }
                        continue;
                    }
                    if (obstacle.type === 'cactus') {
                        // Draw cactus based on variant
                        if (obstacle.variant === 0) {
                            // Small single cactus
                            this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                            
                            // Draw spikes
                            this.ctx.fillRect(obstacle.x - 3, obstacle.y + 10, 3, 5);
                            this.ctx.fillRect(obstacle.x + obstacle.width, obstacle.y + 15, 3, 5);
                        } else if (obstacle.variant === 1) {
                            // Medium double cactus
                            this.ctx.fillRect(obstacle.x, obstacle.y, 15, obstacle.height);
                            this.ctx.fillRect(obstacle.x + 25, obstacle.y + 10, 15, obstacle.height - 10);
                            
                            // Draw spikes
                            this.ctx.fillRect(obstacle.x - 3, obstacle.y + 10, 3, 5);
                            this.ctx.fillRect(obstacle.x + 15, obstacle.y + 5, 3, 5);
                            this.ctx.fillRect(obstacle.x + 40, obstacle.y + 15, 3, 5);
                        } else {
                            // Large triple cactus
                            this.ctx.fillRect(obstacle.x, obstacle.y, 12, obstacle.height);
                            this.ctx.fillRect(obstacle.x + 14, obstacle.y + 5, 12, obstacle.height - 5);
                            this.ctx.fillRect(obstacle.x + 28, obstacle.y, 12, obstacle.height);
                            
                            // Draw spikes
                            this.ctx.fillRect(obstacle.x - 3, obstacle.y + 10, 3, 5);
                            this.ctx.fillRect(obstacle.x + 12, obstacle.y + 15, 3, 5);
                            this.ctx.fillRect(obstacle.x + 26, obstacle.y + 8, 3, 5);
                            this.ctx.fillRect(obstacle.x + 40, obstacle.y + 12, 3, 5);
                        }
                    } else if (obstacle.type === 'pterodactyl') {
                        // Draw pterodactyl with animation
                        if (obstacle.frame === 0) {
                            // Wings up
                            this.ctx.fillRect(obstacle.x, obstacle.y + 10, obstacle.width, 10);
                            this.ctx.fillRect(obstacle.x + 10, obstacle.y, 10, 10);
                        } else {
                            // Wings down
                            this.ctx.fillRect(obstacle.x, obstacle.y + 10, obstacle.width, 10);
                            this.ctx.fillRect(obstacle.x + 10, obstacle.y + 20, 10, 10);
                        }
                    }
                    
                    // Draw collision box in debug mode
                    if (this.debugMode) {
                        this.ctx.strokeStyle = 'blue';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    }
                }
            }
            
            drawPowerUps() {
                for (const powerUp of this.powerUps) {
                    this.ctx.fillStyle = this.getPowerUpColor(powerUp.type);
                    
                    switch (powerUp.type) {
                        case PowerUpType.SHIELD:
                            this.ctx.beginPath();
                            this.ctx.arc(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2, powerUp.width / 2, 0, Math.PI * 2);
                            this.ctx.fill();
                            break;
                            
                        case PowerUpType.SLOWMO:
                            this.ctx.beginPath();
                            this.ctx.moveTo(powerUp.x + powerUp.width / 2 - 8, powerUp.y + powerUp.height / 2 - 8);
                            this.ctx.lineTo(powerUp.x + powerUp.width / 2 + 8, powerUp.y + powerUp.height / 2);
                            this.ctx.lineTo(powerUp.x + powerUp.width / 2 - 8, powerUp.y + powerUp.height / 2 + 8);
                            this.ctx.closePath();
                            this.ctx.fill();
                            break;
                            
                        case PowerUpType.MAGNET:
                            this.ctx.beginPath();
                            this.ctx.moveTo(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2 - 10);
                            this.ctx.lineTo(powerUp.x + powerUp.width / 2 - 8, powerUp.y + powerUp.height / 2);
                            this.ctx.lineTo(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2 + 10);
                            this.ctx.lineTo(powerUp.x + powerUp.width / 2 + 8, powerUp.y + powerUp.height / 2);
                            this.ctx.closePath();
                            this.ctx.fill();
                            break;
                    }
                    
                    // Draw collision box in debug mode
                    if (this.debugMode) {
                        this.ctx.strokeStyle = 'green';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                    }
                }
            }
            
            getPowerUpColor(type) {
                switch (type) {
                    case PowerUpType.SHIELD: return this.isColorBlindMode ? '#009' : '#00f';
                    case PowerUpType.SLOWMO: return this.isColorBlindMode ? '#990' : '#ff0';
                    case PowerUpType.MAGNET: return this.isColorBlindMode ? '#909' : '#f0f';
                    default: return '#333';
                }
            }
            
            drawParticles() {
                this.ctx.fillStyle = this.isColorBlindMode ? '#666' : '#aaa';
                
                for (const particle of this.particles) {
                    this.ctx.globalAlpha = particle.life / 30;
                    this.ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                }
                
                this.ctx.globalAlpha = 1;
            }
            
            drawGems() {
                for (const g of this.gems) {
                    this.ctx.fillStyle = '#0cf';
                    this.ctx.fillRect(g.x, g.y, 8, 8);
                }
            }
            
            drawDebugInfo() {
                const info = [
                    `FPS: ${Math.round(this.fps)}`,
                    `Speed: ${this.speed.toFixed(2)}`,
                    `Score: ${this.score}`,
                    `Distance: ${Math.round(this.distance)}`,
                    `State: ${this.state}`,
                    `Obstacles: ${this.obstacles.length}`,
                    `Power-ups: ${this.powerUps.length}`,
                    `Active Power-ups: ${Array.from(this.player.activePowerUps.keys()).join(', ') || 'None'}`,
                    `Likes: ${this.totalLikes}`
                ];
                
                this.debugPanel.innerHTML = info.join('<br>');
            }
            
            animate(currentTime) {
                this.animationId = requestAnimationFrame((time) => this.animate(time));
                
                // Calculate delta time
                const deltaTime = currentTime - this.lastFrameTime;
                this.lastFrameTime = currentTime;
                
                // Calculate FPS
                this.fps = 1000 / deltaTime;
                
                // Apply slowmo if active
                const effectiveDeltaTime = this.player.activePowerUps.has(PowerUpType.SLOWMO) ? 
                    deltaTime * CONFIG.SLOWMO_FACTOR : deltaTime;
                
                if (this.state === GameState.PLAYING) {
                    this.update(effectiveDeltaTime);
                }
                
                this.draw();
            }

            // Special TikTok effects
            spawnLionBoss(untilTs) {
                const height = 60, width = 70;
                const lion = { type: 'lion', x: this.width, y: this.height - CONFIG.GROUND_HEIGHT - height, width, height };
                this.obstacles.push(lion);
                const move = () => {
                    if (!this.obstacles.includes(lion)) return;
                    lion.x -= (this.speed * 1.8) / 16;
                    if (performance.now() > untilTs || lion.x + lion.width < 0) {
                        this.obstacles = this.obstacles.filter(o => o !== lion);
                        return;
                    }
                    requestAnimationFrame(move);
                };
                requestAnimationFrame(move);
            }

            spawnGhostObstacles() {
                for (let i = 0; i < 3; i++) {
                    const variant = Math.floor(Math.random() * 3);
                    const height = variant === 0 ? 40 : variant === 1 ? 30 : 50;
                    this.obstacles.push({ type: 'cactus', x: this.width + i * 120, y: this.height - CONFIG.GROUND_HEIGHT - height, width: variant === 0 ? 20 : 40, height, variant, ghost: true });
                }
            }

            spawnGemShower() {
                for (let i = 0; i < 25; i++) {
                    this.gems.push({ x: Math.random() * this.width, y: 20 + Math.random() * 40, vx: (Math.random() - 0.5) * 2, vy: Math.random() * -2, life: 600 });
                }
            }
        }

        // Initialize the game when the page loads
        window.addEventListener('load', () => {
            const game = new DinoGame();
            const container = document.getElementById('game-container');
            function applyVisuals() {
                const now = performance.now();
                container.style.transform = game.flipUntil && game.flipUntil > now ? 'rotate(180deg)' : 'none';
                requestAnimationFrame(applyVisuals);
            }
            requestAnimationFrame(applyVisuals);
        });
    </script>
</body>
</html>